# OCR Application - Developer Guide

## 1. Introduction

This guide is intended for developers who wish to understand, modify, or contribute to the OCR application. It provides an overview of the project structure, key components, and development practices.

## 2. Project Structure

The project is organized into several Python modules, Mojo utility files, configuration files, and test files.

*   **Core Python Files (in `/app/`):**
    *   `main.py`: Entry point for the Command-Line Interface (CLI). Handles argument parsing and invokes the OCR orchestrator.
    *   `gui_app.py`: Entry point for the CustomTkinter-based Graphical User Interface (GUI). Manages UI elements and user interactions, and calls the OCR orchestrator in a separate thread.
    *   `ocr_workflow_orchestrator.py`: Contains the `OCRWorkflowOrchestrator` class, which coordinates the entire OCR pipeline by managing and calling various processing modules.
    *   `config_loader.py`: Handles loading and validation of configuration from YAML files (e.g., `config_dev.yaml`). Also sets up logging.
    *   `custom_exceptions.py`: Defines custom exception classes used throughout the application for more specific error handling.
    *   `preprocessing_module.py`: Contains classes for image preprocessing steps:
        *   `ImageBinarizer`: Converts images to binary (black and white) using OpenCV.
        *   `ImageDeskewer`: Detects and corrects skew in binarized images using OpenCV.
        *   `GeometricCorrector`: Applies geometric correction using an ONNX model (currently a dummy model).
    *   `recognition_module.py`: Contains the `ONNXRecognizer` class for performing text recognition using an ONNX model (currently a dummy model).
    *   `postprocessing_module.py`: Contains classes for text postprocessing:
        *   `TextCleaner`: Cleans recognized text based on a character whitelist.
        *   `SpellCorrector`: Performs dictionary-based spell checking on cleaned text.
        *   `PostprocessingModulePlaceholder`: An older placeholder, largely superseded by `TextCleaner` and `SpellCorrector` but kept for structural reference if needed.

*   **Mojo Utility Files (in `/app/`):**
    *   `mojo_image_utils.mojo`: Contains Mojo functions for image processing tasks (e.g., `normalize_flat_u8_to_float32_mojo`, `calculate_histogram_mojo`, `calculate_bounding_box_mojo`). These are called from Python with fallbacks if Mojo SDK is unavailable.
    *   `mojo_recognizer_utils.mojo`: Contains example Mojo functions for tensor operations, primarily for demonstration of Python-Mojo interop.

*   **Models and Data (in `/app/`):**
    *   `models/`: This directory is intended to store ONNX model files. The application currently uses dummy models (`dummy_geometric_model.onnx`, `dummy_recognition_model.onnx`) which are generated by helper scripts or created as placeholders if missing.
    *   `default_dict.txt`: A default dictionary file used by `SpellCorrector`.

*   **Configuration (in `/app/`):**
    *   `config_dev.yaml`: The default configuration file. It's created with default settings if not found.

*   **Tests (in `/app/tests/`):**
    *   `test_*.py`: Unit test files for corresponding Python modules (e.g., `test_preprocessing_module.py`).
    *   `MANUAL_INTEGRATION_TESTS.md`: Manual test cases for the CLI.
    *   `MANUAL_GUI_TESTS.md`: Manual test plan for the GUI.

*   **Helper Scripts (in `/app/`):**
    *   `generate_dummy_geometric_model.py`: Script to create the dummy geometric correction ONNX model.
    *   `generate_dummy_recognition_model.py`: Script to create the dummy text recognition ONNX model.

## 3. Key Modules and Flow

The core of the application is the `OCRWorkflowOrchestrator`. It orchestrates the processing pipeline as follows:

1.  **Load Image (`load_image`)**: Currently loads a dummy NumPy array. In a real scenario, it would load an image file using Pillow/OpenCV and convert it to a NumPy array.
2.  **Binarize (`ImageBinarizer.binarize`)**: Converts the image to binary (black and white `uint8` NumPy array).
3.  **Deskew (`ImageDeskewer.deskew`)**: Corrects any skew in the binarized image (`uint8` NumPy array).
4.  **Normalize (Mojo/NumPy)**: Converts the `uint8` deskewed image to a `float32` NumPy array, typically normalized to `[0, 1]`. This step attempts to use `normalize_flat_u8_to_float32_mojo` and falls back to NumPy if Mojo is unavailable.
5.  **Geometric Correction (`GeometricCorrector.correct`)**: Applies geometric correction using an ONNX model. Takes `float32` NumPy array.
6.  **Recognition (`ONNXRecognizer.predict`)**: Performs text recognition using an ONNX model. Takes `float32` NumPy array. Returns raw text and confidence.
7.  **Text Cleaning (`TextCleaner.clean_text`)**: Cleans the recognized text using a character whitelist.
8.  **Spell Check (`SpellCorrector.correct_text`)**: Performs dictionary-based spell checking on the cleaned text.

The orchestrator manages the data flow (primarily NumPy arrays for images, dictionaries for text data) between these components.

## 4. Configuration System

*   Configuration is managed by `config_loader.py` through the `load_config()` function.
*   The primary configuration file is `config_dev.yaml` (or a custom path provided via CLI/GUI).
*   If `config_dev.yaml` is not found when `load_config("config_dev.yaml")` is called (e.g., on first run or if orchestrator defaults to it), `create_default_config_if_not_exists()` is invoked. This function:
    *   Creates `config_dev.yaml` with default settings for model paths, performance options, postprocessing parameters (whitelist, dictionary path), deskewer settings, and logging configuration.
    *   It also attempts to create placeholder dummy model files and a minimal `default_dict.txt` if these are missing, to ensure the application can start with a basic functional state.
*   The loaded configuration (a Python dictionary) is used by the `OCRWorkflowOrchestrator` to initialize its sub-modules with appropriate settings.
*   Logging for the entire application (levels, handlers, formatters) is configured from the `logging` section of the loaded YAML file, falling back to `DEFAULT_LOGGING_CONFIG` in `config_loader.py` if issues occur.

## 5. Error Handling

*   Custom exceptions are defined in `custom_exceptions.py` (e.g., `OCRConfigurationError`, `OCRPipelineError`, `OCRFileNotFoundError`, `OCRModelError`, `OCRImageProcessingError`).
*   **Modules:** Individual modules (preprocessing, recognition, postprocessing, config_loader) are responsible for catching specific internal errors (e.g., ONNX runtime errors, OpenCV errors, file I/O errors) and raising appropriate custom exceptions (or standard Python exceptions like `ValueError`, `TypeError` for contract violations). `raise ... from ...` is used to preserve original error context.
*   **Orchestrator:** The `OCRWorkflowOrchestrator.process_document()` method catches exceptions from the sub-modules it calls. It wraps these more specific errors (including custom ones like `OCRModelError` or standard ones like `FileNotFoundError` from `load_image`) into a general `OCRPipelineError`. This provides a consistent error type to the UI layers. Initialization errors in the orchestrator's `__init__` (e.g., config loading failure, module init failure) will also typically raise `OCRConfigurationError` or `OCRPipelineError`.
*   **UI Layers (`main.py`, `gui_app.py`):**
    *   The CLI (`main.py`) specifically catches `OCRFileNotFoundError`, `OCRConfigurationError`, and `OCRPipelineError` to provide user-friendly error messages and exit gracefully. It also has a global `try-except Exception` for unexpected issues.
    *   The GUI (`gui_app.py`) similarly catches these custom exceptions during orchestrator initialization and during the threaded OCR task, displaying errors to the user via `CTkMessagebox` and the status bar.

## 6. Logging

*   Standard Python `logging` module is used.
*   Each Python module/class typically obtains a logger instance using `logger = logging.getLogger(__name__)`.
*   Logging configuration (level, format, handlers) is loaded from the YAML configuration file by `config_loader.py`. A default logging configuration (`DEFAULT_LOGGING_CONFIG` in `config_loader.py`) is used if the config file is missing or lacks a valid `logging` section.
*   The CLI (`main.py`) provides a `--verbose` flag, which attempts to set the root logging level to DEBUG for more detailed output.
*   Mojo functions currently use simple `print()` statements for basic logging, which will appear in the console output if Mojo execution occurs.

## 7. Mojo Integration

*   **Mojo Code Files:**
    *   `mojo_image_utils.mojo`: Contains utilities like `normalize_flat_u8_to_float32_mojo`, `calculate_histogram_mojo`, and `calculate_bounding_box_mojo`.
    *   `mojo_recognizer_utils.mojo`: Contains `example_mojo_tensor_operation` for demonstration.
*   **Python-Mojo Interaction:**
    *   Python calls Mojo functions using `from mojo.mojo.python import Python` and then `Python.import_module("mojo_module_name")` to load the `.mojo` file. Functions are then called as attributes of the imported module object.
    *   Data is passed to Mojo primarily as Python lists (e.g., flattened image data). Mojo functions convert these to `Python.List[IntLiteral]` or `Python.List[FloatLiteral]`.
    *   Mojo functions return results as `PythonObject` (e.g., `Python.List[...].to_object()` or `Python.Tuple(...).to_object()` or `Python.None`). Python code then converts these PythonObjects back to standard Python types (e.g., `list()`, `tuple()`, or checking against `None`).
*   **Fallback Mechanism:**
    *   In Python modules that call Mojo functions (e.g., `ocr_workflow_orchestrator.py` for normalization, demonstration code in `preprocessing_module.py`), there's a check at module load time for Mojo SDK availability (`try import Python from mojo.mojo.python`).
    *   Flags like `mojo_normalization_available` are set.
    *   During function calls, if Mojo is available, the Mojo function is attempted within a `try-except` block. If it fails, or if Mojo was not available initially, the code falls back to an equivalent Python/NumPy implementation. This ensures the application remains functional even without the Mojo SDK.

## 8. Testing

*   **Unit Tests:**
    *   Located in the `/app/tests/` directory (e.g., `test_preprocessing_module.py`, `test_config_loader.py`).
    *   Use the standard Python `unittest` module.
    *   Focus on testing individual classes and methods with various inputs, including edge cases and error conditions. Mocking is used where necessary (e.g., in `test_ocr_workflow_orchestrator.py` to simulate sub-module errors).
    *   To run all unit tests, navigate to the `/app` directory and (conceptually, depending on test runner setup):
        ```bash
        python -m unittest discover tests
        ```
        Or run individual test files: `python -m unittest tests.test_preprocessing_module`
*   **Manual Test Plans:**
    *   `tests/MANUAL_INTEGRATION_TESTS.md`: Outlines test cases for end-to-end testing of the CLI (`main.py`).
    *   `tests/MANUAL_GUI_TESTS.md`: Describes a manual test plan for the GUI application (`gui_app.py`).

## 9. Dependencies

*   **Main Python Packages:**
    *   `Pillow`
    *   `numpy`
    *   `PyYAML`
    *   `opencv-python`
    *   `onnxruntime`
    *   `customtkinter`
*   **System Dependencies for GUI:**
    *   **Tkinter**: `customtkinter` requires a functional Tkinter installation (e.g., `python3-tk` on Debian/Ubuntu).
*   **Optional for Performance:**
    *   **Mojo SDK**: For running Mojo-accelerated functions. Ensure it's installed and `MODULE_PATH` (if used by your Mojo setup) and `PYTHONPATH` are configured so Python can find the `.mojo` files and the Mojo libraries.

## 10. Contribution Guidelines (Very Brief)

*   Follow the existing code style (e.g., type hinting, logging practices, error handling patterns).
*   Add unit tests for any new features or significant bug fixes.
*   Update relevant documentation (`USER_GUIDE.md`, `DEVELOPER_GUIDE.md`, docstrings) as needed.
*   Ensure code is well-commented where complex logic exists.
*   Test thoroughly before submitting changes.
